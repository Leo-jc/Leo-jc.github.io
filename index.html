<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/fork-awesome@1.2.0/css/fork-awesome.min.css">

<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-C++多线程笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/28/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2025-02-28T08:25:55.000Z" itemprop="datePublished">2025-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/28/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/">C++多线程笔记</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="C-11多线程笔记"><a href="#C-11多线程笔记" class="headerlink" title="C++11多线程笔记"></a>C++11多线程笔记</h2><h3 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1.创建线程"></a>1.创建线程</h3><p>多线程的头文件 <code>#include&lt;thread&gt;</code></p>
<p>创建线程的基本格式 <code>std::thread t(function_name,args...);</code>其中function_name是线程执行的函数，args是function_name的参数列表。</p>
<h4 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h4><h5 id="使用-std-thread-直接创建"><a href="#使用-std-thread-直接创建" class="headerlink" title="使用 std::thread 直接创建"></a><strong>使用 <code>std::thread</code> 直接创建</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">void thread_func(int num, const std::string&amp; msg) &#123;</span><br><span class="line">	std::cout &lt;&lt; &quot;Thread: &quot; &lt;&lt; num &lt;&lt; &quot;, Message: &quot; &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	// 直接传递函数和参数</span><br><span class="line">	std::thread t(thread_func, 42, &quot;Hello from thread!&quot;);</span><br><span class="line"></span><br><span class="line">	// 等待线程结束</span><br><span class="line">	t.join();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-Lambda-表达式"><a href="#使用-Lambda-表达式" class="headerlink" title="使用 Lambda 表达式"></a><strong>使用 Lambda 表达式</strong></h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int value = 100;</span><br><span class="line"></span><br><span class="line">    //std::thread t([&amp;value]() &#123;</span><br><span class="line">    //    std::cout &lt;&lt; &quot;Lambda thread. Value: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    //    value = 200; // 通过引用修改外部变量</span><br><span class="line">    //    &#125;);</span><br><span class="line">    std::thread t([&amp;value] &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Lambda thread. Value: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">        value = 200; // 通过引用修改外部变量</span><br><span class="line">        &#125;);</span><br><span class="line">    t.join();</span><br><span class="line">    std::cout &lt;&lt; &quot;Modified value: &quot; &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="传递成员函数"><a href="#传递成员函数" class="headerlink" title="传递成员函数"></a><strong>传递成员函数</strong></h5><p>若需调用类的成员函数作为线程入口，需传递对象实例的指针或引用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    void member_func(const std::string&amp; msg) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Member function: &quot; &lt;&lt; msg &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    </span><br><span class="line">    // 传递成员函数和对象实例</span><br><span class="line">    std::thread t(&amp;MyClass::member_func, &amp;obj, &quot;Calling member function.&quot;);</span><br><span class="line">    //成员函数需要显式取地址</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-std-async-异步执行"><a href="#使用-std-async-异步执行" class="headerlink" title="使用 std::async 异步执行"></a><strong>使用 <code>std::async</code> 异步执行</strong></h5><p><code>std::async</code> 返回一个 <code>std::future</code> 对象，可以异步执行任务并获取结果。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line"></span><br><span class="line">int async_task(int x) &#123;</span><br><span class="line">    return x * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    // 启动异步任务（默认策略为 std::launch::async | std::launch::deferred）</span><br><span class="line">    std::future&lt;int&gt; fut = std::async(async_task, 21);</span><br><span class="line">    </span><br><span class="line">    // 获取结果（阻塞直到完成）</span><br><span class="line">    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用-std-packaged-task"><a href="#使用-std-packaged-task" class="headerlink" title="使用 std::packaged_task"></a><strong>使用 <code>std::packaged_task</code></strong></h5><p><code>std::packaged_task</code> 将可调用对象与 <code>std::future</code> 绑定，便于在线程间传递任务。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::packaged_task&lt;int(int)&gt; task([](int x) &#123;</span><br><span class="line">        return x * 3;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    std::future&lt;int&gt; fut = task.get_future();</span><br><span class="line">    </span><br><span class="line">    // 将任务移动到线程中执行</span><br><span class="line">    std::thread t(std::move(task), 10);</span><br><span class="line">    t.join();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; fut.get() &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-线程函数中的数据未定义错误"><a href="#2-线程函数中的数据未定义错误" class="headerlink" title="2.线程函数中的数据未定义错误"></a>2.线程函数中的数据未定义错误</h3><h4 id="传递临时变量的问题："><a href="#传递临时变量的问题：" class="headerlink" title="传递临时变量的问题："></a>传递临时变量的问题：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">void foo(int&amp; x) &#123;</span><br><span class="line">    x += 1;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::thread t(foo, 1); // 传递临时变量</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个名为<code>foo</code>的函数，它接受一个整数引用作为参数，并将该引用加1。然后，我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及一个临时变量<code>1</code>作为参数传递给它。这样会导致在线程函数执行时，临时变量<code>1</code>被销毁，从而导致未定义行为。</p>
<p>解决方案是将变量复制到一个持久的对象中，然后将该对象传递给线程。例如，我们可以将<code>1</code>复制到一个<code>int</code>类型的变量中，然后将该变量的引用传递给线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">void foo(int&amp; x) &#123;</span><br><span class="line">    x += 1;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 1; // 将变量复制到一个持久的对象中</span><br><span class="line">    std::thread t(foo, std::ref(x)); // 将变量的引用传递给线程</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="传递指针或引用指向局部变量的问题："><a href="#传递指针或引用指向局部变量的问题：" class="headerlink" title="传递指针或引用指向局部变量的问题："></a>传递指针或引用指向局部变量的问题：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">void foo(int* ptr) &#123;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; // 访问已经被销毁的指针</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int x = 1;</span><br><span class="line">    std::thread t(foo, &amp;x); // 传递指向局部变量的指针</span><br><span class="line">	t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个名为<code>foo</code>的函数，它接受一个整型指针作为参数，并输出该指针所指向的整数值。然后，我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及指向局部变量<code>x</code>的指针作为参数传递给它。这样会导致在线程函数执行时，指向局部变量<code>x</code>的指针已经被销毁，从而导致未定义行为。</p>
<p>解决方案是将指针或引用指向堆上的变量，或使用<code>std::shared_ptr</code>等智能指针来管理对象的生命周期。例如，我们可以使用<code>new</code>运算符在堆上分配一个整数变量，并将指针指向该变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">void foo(int* ptr) &#123;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl;</span><br><span class="line">    delete ptr; // 在使用完指针后，需要手动释放内存</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int* ptr = new int(1); // 在堆上分配一个整数变量</span><br><span class="line">    std::thread t(foo, ptr); // 将指针传递给线程</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="传递指针或引用指向已释放的内存的问题："><a href="#传递指针或引用指向已释放的内存的问题：" class="headerlink" title="传递指针或引用指向已释放的内存的问题："></a>传递指针或引用指向已释放的内存的问题：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">void foo(int&amp; x) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; // 访问已经被释放的内存</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	int* ptr = new int(1);</span><br><span class="line">    std::thread t(foo, *ptr); // 传递已经释放的内存</span><br><span class="line">    delete ptr;</span><br><span class="line">	t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们定义了一个名为<code>foo</code>的函数，它接受一个整数引用作为参数，并输出该引用的值。然后，我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及一个已经被释放的指针所指向的整数值作为参数传递给它解决方案是确保在线程函数执行期间，被传递的对象的生命周期是有效的。例如，在主线程中创建并初始化对象，然后将对象的引用传递给线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">void foo(int&amp; x) &#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int x = 1;</span><br><span class="line">    std::thread t(foo, std::ref(x)); // 将变量的引用传递给线程</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个名为<code>x</code>的整数变量，并初始化为<code>1</code>。然后，我们创建了一个名为<code>t</code>的线程，将<code>foo</code>函数以及变量<code>x</code>的引用作为参数传递给它。这样可以确保在线程函数执行期间，变量<code>x</code>的生命周期是有效的。</p>
<h4 id="类成员函数作为入口函数，类对象被提前释放"><a href="#类成员函数作为入口函数，类对象被提前释放" class="headerlink" title="类成员函数作为入口函数，类对象被提前释放"></a>类成员函数作为入口函数，类对象被提前释放</h4><p>错误示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; std::this_thread::get_id() </span><br><span class="line">        &lt;&lt; &quot; started&quot; &lt;&lt; std::endl;</span><br><span class="line">        // do some work</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; std::this_thread::get_id() </span><br><span class="line">        &lt;&lt; &quot; finished&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">void test()&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    std::thread t(&amp;MyClass::func, &amp;obj);</span><br><span class="line">    // obj 被提前销毁了，会导致未定义的行为</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">	test();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，在创建线程之后，obj 对象立即被销毁了，这会导致在线程执行时无法访问 obj 对象，可能会导致程序崩溃或者产生未定义的行为。</p>
<p>为了避免这个问题，可以使用 std::shared_ptr 来管理类对象的生命周期，确保在线程执行期间对象不会被销毁。具体来说，可以在创建线程之前，将类对象的指针封装在一个 std::shared_ptr 对象中，并将其作为参数传递给线程。这样，在线程执行期间，即使类对象的所有者释放了其所有权，std::shared_ptr 仍然会保持对象的生命周期，直到线程结束。</p>
<p>以下是使用 std::shared_ptr 修复上面错误的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">public:</span><br><span class="line">    void func() &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; std::this_thread::get_id() </span><br><span class="line">        &lt;&lt; &quot; started&quot; &lt;&lt; std::endl;</span><br><span class="line">        // do some work</span><br><span class="line">        std::cout &lt;&lt; &quot;Thread &quot; &lt;&lt; std::this_thread::get_id() </span><br><span class="line">        &lt;&lt; &quot; finished&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    std::shared_ptr&lt;MyClass&gt; obj = std::make_shared&lt;MyClass&gt;();</span><br><span class="line">    std::thread t(&amp;MyClass::func, obj);</span><br><span class="line">    t.join();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，使用 std::make_shared 创建了一个 MyClass 类对象，并将其封装在一个 std::shared_ptr 对象中。然后，将 std::shared_ptr 对象作为参数传递给线程。这样，在线程执行期间，即使 obj 对象的所有者释放了其所有权，std::shared_ptr 仍然会保持对象的生命周期，直到线程结束。</p>
<h4 id="入口函数为类的私有成员函数"><a href="#入口函数为类的私有成员函数" class="headerlink" title="入口函数为类的私有成员函数"></a>入口函数为类的私有成员函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line"></span><br><span class="line">class MyClass &#123;</span><br><span class="line">private:</span><br><span class="line">friend void myThreadFunc(MyClass* obj);</span><br><span class="line">void privateFunc()&#123;</span><br><span class="line">std::cout &lt;&lt; &quot;Thread &quot; </span><br><span class="line">&lt;&lt; std::this_thread::get_id() &lt;&lt; &quot; privateFunc&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void myThreadFunc(MyClass* obj) &#123;</span><br><span class="line">obj-&gt;privateFunc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">MyClass obj;</span><br><span class="line">std::thread thread_1(myThreadFunc, &amp;obj);</span><br><span class="line">thread_1.join();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，将 <code>myThreadFunc</code> 定义为 <code>MyClass</code> 类的友元函数，并在函数中调用 <code>privateFunc</code> 函数。在创建线程时，需要将类对象的指针作为参数传递给线程。</p>
<h3 id="3-互斥量解决多线程数据共享问题"><a href="#3-互斥量解决多线程数据共享问题" class="headerlink" title="3. 互斥量解决多线程数据共享问题"></a>3. 互斥量解决多线程数据共享问题</h3><h4 id="互斥量类型"><a href="#互斥量类型" class="headerlink" title="互斥量类型"></a><strong>互斥量类型</strong></h4><ol>
<li><strong><code>std::mutex</code></strong></li>
</ol>
<ul>
<li><p><strong>基本互斥量</strong>：不可递归锁定，不可超时等待。</p>
</li>
<li><p><strong>适用场景</strong>：简单的独占访问需求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 访问共享资源</span></span><br><span class="line">    mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong><code>std::recursive_mutex</code></strong></li>
</ol>
<ul>
<li><p><strong>递归互斥量</strong>：同一线程可多次锁定，需等比例解锁。</p>
</li>
<li><p><strong>适用场景</strong>：需要递归调用的函数（如递归函数中访问共享资源）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::recursive_mutex rec_mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive_func</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    rec_mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 递归调用</span></span><br><span class="line">        <span class="built_in">recursive_func</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rec_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong><code>std::timed_mutex</code></strong></li>
</ol>
<ul>
<li><p><strong>超时互斥量</strong>：支持尝试锁定或超时等待（<code>try_lock_for()</code>、<code>try_lock_until()</code>）。</p>
</li>
<li><p><strong>适用场景</strong>：避免长时间阻塞（如任务调度）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::timed_mutex timed_mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">timed_thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timed_mtx.<span class="built_in">try_lock_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>))) &#123;</span><br><span class="line">        <span class="comment">// 锁定成功，访问资源</span></span><br><span class="line">        timed_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 超时处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="4">
<li><strong><code>std::shared_mutex</code> (C++17)</strong></li>
</ol>
<ul>
<li><p><strong>共享互斥量</strong>：支持读写锁（<code>lock_shared()</code> 读锁定，<code>lock()</code> 写锁定）。</p>
</li>
<li><p><strong>适用场景</strong>：读多写少的场景（如缓存、配置管理）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;shared_mutex&gt;</span></span></span><br><span class="line">std::shared_mutex sh_mtx;</span><br><span class="line"><span class="type">int</span> shared_data;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sh_mtx.<span class="built_in">lock_shared</span>();</span><br><span class="line">    <span class="comment">// 读取 shared_data</span></span><br><span class="line">    sh_mtx.<span class="built_in">unlock_shared</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sh_mtx.<span class="built_in">lock</span>();</span><br><span class="line">    <span class="comment">// 修改 shared_data</span></span><br><span class="line">    sh_mtx.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="锁管理类（RAII-封装）"><a href="#锁管理类（RAII-封装）" class="headerlink" title="锁管理类（RAII 封装）"></a><strong>锁管理类（RAII 封装）</strong></h4><ol>
<li><strong><code>std::lock_guard</code></strong></li>
</ol>
<ul>
<li><p><strong>自动锁定&#x2F;解锁</strong>：不可手动控制，作用域结束时自动释放锁。</p>
</li>
<li><p><strong>适用场景</strong>：简单的作用域内锁定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    <span class="comment">// 自动锁定，作用域结束自动解锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong><code>std::unique_lock</code></strong></li>
</ol>
<ul>
<li><p><strong>灵活控制</strong>：支持延迟锁定、手动解锁、所有权转移。</p>
</li>
<li><p><strong>适用场景</strong>：需要精细控制锁（如条件变量、超时锁定）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flexible_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx, std::defer_lock)</span></span>;</span><br><span class="line">    lock.<span class="built_in">lock</span>();        <span class="comment">// 手动锁定</span></span><br><span class="line">    <span class="comment">// 访问资源</span></span><br><span class="line">    lock.<span class="built_in">unlock</span>();      <span class="comment">// 手动解锁（可选）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><strong><code>std::scoped_lock</code> (C++17)</strong></li>
</ol>
<ul>
<li><p><strong>多互斥量锁定</strong>：同时锁定多个互斥量，避免死锁。</p>
</li>
<li><p><strong>适用场景</strong>：需要同时访问多个共享资源。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">multi_lock_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::scoped_lock <span class="title">lock</span><span class="params">(mtx1, mtx2)</span></span>;</span><br><span class="line">    <span class="comment">// 同时锁定 mtx1 和 mtx2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="同步与条件变量"><a href="#同步与条件变量" class="headerlink" title="同步与条件变量"></a><strong>同步与条件变量</strong></h4><ol>
<li><strong><code>std::condition_variable</code></strong></li>
</ol>
<ul>
<li><p><strong>线程间通信</strong>：等待条件成立或通知其他线程。</p>
</li>
<li><p><strong>适用场景</strong>：生产者-消费者模型、任务队列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;condition_variable&gt;</span></span></span><br><span class="line">std::mutex mtx;</span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="type">bool</span> data_ready = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data_ready = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.<span class="built_in">notify_one</span>(); <span class="comment">// 通知消费者</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">    cv.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> data_ready; &#125;); <span class="comment">// 等待条件成立</span></span><br><span class="line">    <span class="comment">// 消费数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="避免死锁的通用方法"><a href="#避免死锁的通用方法" class="headerlink" title="避免死锁的通用方法"></a><strong>避免死锁的通用方法</strong></h4><ol>
<li><strong>固定锁定顺序</strong></li>
</ol>
<ul>
<li><p><strong>规则</strong>：所有线程按相同顺序锁定互斥量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thread2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1)</span></span>; <span class="comment">// 与 thread1 相同顺序</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><strong>使用 <code>std::lock</code></strong></li>
</ol>
<ul>
<li><p><strong>原子化锁定</strong>：同时锁定多个互斥量，避免死锁。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mtx1, mtx2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">safe_lock_func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock1</span><span class="params">(mtx1, std::defer_lock)</span></span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock2</span><span class="params">(mtx2, std::defer_lock)</span></span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lock1, lock2); <span class="comment">// 原子化锁定</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h4 id="线程安全的数据结构设计"><a href="#线程安全的数据结构设计" class="headerlink" title="线程安全的数据结构设计"></a><strong>线程安全的数据结构设计</strong></h4><ol>
<li><strong>封装互斥量与数据</strong></li>
</ol>
<ul>
<li><p><strong>原则</strong>：将共享数据与互斥量封装在同一类中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadSafeQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::queue&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> std::mutex mtx;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        data.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">try_pop</span><span class="params">(<span class="type">int</span>&amp; val)</span> </span>&#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        val = data.<span class="built_in">front</span>();</span><br><span class="line">        data.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h4><table>
<thead>
<tr>
<th><strong>场景</strong></th>
<th><strong>推荐方法</strong></th>
</tr>
</thead>
<tbody><tr>
<td>简单独占访问</td>
<td><code>std::mutex</code> + <code>std::lock_guard</code></td>
</tr>
<tr>
<td>需要延迟锁定或手动控制</td>
<td><code>std::mutex</code> + <code>std::unique_lock</code></td>
</tr>
<tr>
<td>同时锁定多个互斥量</td>
<td><code>std::scoped_lock</code> (C++17)</td>
</tr>
<tr>
<td>读多写少</td>
<td><code>std::shared_mutex</code> + 读写锁</td>
</tr>
<tr>
<td>避免死锁</td>
<td>固定顺序锁定或 <code>std::lock</code></td>
</tr>
<tr>
<td>线程间通信</td>
<td><code>std::condition_variable</code></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/28/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/" data-id="cm7oilb240000qka69uu906ld" data-title="C++多线程笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2025/02/28/hello-world/" class="article-date">
  <time class="dt-published" datetime="2025-02-28T08:21:04.657Z" itemprop="datePublished">2025-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2025/02/28/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2025/02/28/hello-world/" data-id="cm7oi8jei00004sa64gk26rti" data-title="Hello World" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2025/02/">February 2025</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2025/02/28/C++%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/">C++多线程笔记</a>
          </li>
        
          <li>
            <a href="/2025/02/28/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2025 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>